-- Key mapping definitions for the "keymap" module

-- Compile Lua scripts and download the generated bytecode to the keyboard using:
-- $ daluac core.lua keymap.lua >keymap.bin && dfu-util -a1 -D keymap.bin
-- Notes:
--   - Scripts are compiled in listed order.
--   - Each script is treated as an anonymous function and composed sequentially.
--   - Return values are passed as arguments to the next script.
--   - The first script receives the module name ("keymap") as its only argument.
--   - The final script must return the keymap driver in a table.

-- Note: Any runtime error in this script will cause a crash during the firmware boot.
-- For example, the package module does not define non_existent_function() and thus
-- package.non_existent_function("nop") will cause a crash!

local fw = require "fw"



-------- Custom keymaps
local FN    = Pseudo()
local FN2   = Pseudo()

local F1    = Lit("F1")
local F2    = Lit("F2")
local F3    = Lit("F3")
local F4    = Lit("F4")
local F5    = Lit("F5")
local F6    = Lit("F6")
local F7    = Lit("F7")
local F8    = Lit("F8")
local F9    = Lit("F9")
local F10   = Lit("F10")
local F11   = Lit("F11")
local F12   = Lit("F12")

local LEFT  = Lit("LEFT")
local RIGHT = Lit("RIGHT")
local UP    = Lit("UP")
local DOWN  = Lit("DOWN")

local INS   = Lit("INS")
local DEL   = Lit("DEL")
local HOME  = Lit("HOME")
local END   = Lit("END")
local PGUP  = Lit("PGUP")
local PGDN  = Lit("PGDN")

local SPACE = Lit("SPACE")
local LSHFT = Lit("LSHFT")
local RSHFT = Lit("RSHFT")
local LCTRL = Lit("LCTRL")
local RCTRL = Lit("RCTRL")

-- Tap FN -> ESC
local tFN = TapHold(Lit("ESC"), FN, HoldOnPress)

-- Hold ENTER -> FN
local tENTER = TapHold(Lit("ENTER"), FN, HoldOnPress)

-- Tap SPACE -> SPACE, Hold SPACE -> RSHFT, Tap + Tap + Hold Space -> Space
local tSPACE = TapHold(SPACE, RSHFT, HoldOnRelease|QuickRelease)
local tSPACE = TapSeq(tSPACE, tSPACE, SPACE)

-- LSHFT w/tSPACE (not w/RSHFT) -> SPACE
-- Double LSHFT -> CapsLock, LSHFT (when CapsLock on) -> CapsLock
local CAPSLOCK = Lit("CAPSLOCK")
local mLSHFT = ModIf(tSPACE, SPACE,
    ModIf(Predicate(function() return Lamp.is_lamp_active(LAMP_CAPSLOCK) end),
        CAPSLOCK, TapSeq(LSHFT, CAPSLOCK)) )
Lamp(LAMP_CAPSLOCK, mLSHFT)

-- Tap RSHFT -> INS
local tRSHFT = TapHold(INS, RSHFT, HoldOnPress|QuickRelease)

-- FN + n or hold n -> Fn
local QuickTap = TapOnPress|TapOnRelease|HoldIsTap
local m1 = ModIf(FN, F1, TapHold(Lit("1"), F1, QuickTap))
local m2 = ModIf(FN, F2, TapHold(Lit("2"), F2, QuickTap))
local m3 = ModIf(FN, F3, TapHold(Lit("3"), F3, QuickTap))
local m4 = ModIf(FN, F4, TapHold(Lit("4"), F4, QuickTap))
local m5 = ModIf(FN, F5, TapHold(Lit("5"), F5, QuickTap))
local m6 = ModIf(FN, F6, TapHold(Lit("6"), F6, QuickTap))
local m7 = ModIf(FN, F7, TapHold(Lit("7"), F7, QuickTap))
local m8 = ModIf(FN, F8, TapHold(Lit("8"), F8, QuickTap))
local m9 = ModIf(FN, F9, TapHold(Lit("9"), F9, QuickTap))
local m0 = ModIf(FN, F10, TapHold(Lit("0"), F10, QuickTap))
local mMINUS = ModIf(FN, F11, TapHold(Lit("-"), F11, QuickTap))
local mEQUAL = ModIf(FN, F12, TapHold(Lit("="), F12, QuickTap))

-- FN + H/J/K/L -> arrow keys, FN2 + H/J/K/L -> HOME/PGDN/PGUP/END
local mH = ModIf(FN, LEFT, ModIf(FN2, HOME, Lit("H")))
local mJ = ModIf(FN, DOWN, ModIf(FN2, PGDN, Lit("J")))
local mK = ModIf(FN, UP, ModIf(FN2, PGUP, Lit("K")))
local mL = ModIf(FN, RIGHT, ModIf(FN2, END, Lit("L")))

-- FN + P -> PrtScr
local mP = ModIf(FN, Lit("PRTSCR"), Lit("P"))

-- FN + [ -> Break/Pause
local mLBRAC = ModIf(FN, Lit("PAUSE"), Lit("["))

-- FN + BKSP -> DEL
local mBKSP = ModIf(FN, DEL, Lit("BKSP"))

-- FN + DOWN -> SCRLOCK
-- Most Linux Distros do not handle SCRLOCK but Windows does.
local mDOWN = ModIf(FN, Lit("SCRLOCK"), DOWN)
-- Todo: Custom lamp_t that enables a jiggler while SCRLOCK lamp is on.
Lamp(LAMP_SCRLOCK, LED_BOTTOM_RIGHT)

-- ENTER + ` -> POWER
local mGRV = ModIf(tENTER, Lit("POWER"), Lit("`"))

-- ENTER + TAB -> fw.switchover(), Hold TAB -> FN2
local mTAB = ModIf(tENTER,
    -- Directly executing fw.switchover() is safe here because tENTER is mapped to
    -- a non-physical key (FN). However, if it were mapped to e.g. CTRL, fw.switchover()
    -- should be called through fw.execute_later().
    -- Function(fw.switchover),
    Function(function() fw.execute_later(fw.switchover) end),
    TapHold(Lit("TAB"), FN2, HoldOnPress))

-- ENTER + B -> fw.reboot_to_bootloader()
local mB = ModIf(tENTER, Function(fw.reboot_to_bootloader), Lit("B"))

-- Not so useful:
-- local tRIGHT = TapSeq(RIGHT, END)

-------- Generate keymap table from the user-defined layout.
local function layout(keymaps)
    assert( #keymaps == KEY_LED_COUNT )
    for i, keymap in ipairs(keymaps) do
        if type(keymap) == "string" then
            keymaps[i] = Lit(keymap)
        else
            -- It should be an instance of Base.
            assert( keymap._press, "keymaps["..i.."] not valid" )
            -- If the keymap is associated with a lamp, link the lamp to the slot
            -- currently occupied by the keymap.
            if keymap._lamp then
                keymap._lamp.m_slot_index = i
                keymap._lamp = nil
            end
        end
    end

    return keymaps
end

Base.c_keymap_table = layout {
    mGRV, m1, m2, m3, m4, m5, m6, m7, m8, m9, m0, mMINUS, mEQUAL, mBKSP, DEL,
    mTAB, "Q", "W", "E", "R", "T", "Y", "U", "I", "O", mP, mLBRAC, "]", "\\", HOME,
    tFN, "A", "S", "D", "F", "G", mH, mJ, mK, mL, ";", "'", tENTER, PGUP,
    mLSHFT, "Z", "X", "C", "V", mB, "N", "M", ",", ".", "/", tRSHFT, UP, PGDN,
    "LALT", "LGUI", LCTRL, tSPACE, RCTRL, "RALT", LEFT, mDOWN, RIGHT
}

-- https://stackoverflow.com/questions/21737613/image-of-hsv-color-wheel-for-opencv
Effect.c_active_effect = FingerTracer(8192, 30 * HSV_HUE_STEPS // 360, 255, 255) -- Orange
-- Effect.c_active_effect = Fixed(90 * HSV_HUE_STEPS // 360, 255, 255)   -- Spring Green
-- Effect.c_active_effect = Fixed(120 * HSV_HUE_STEPS // 360, 255, 255)  -- Mild Green



-- Return the passed keymap and indicator lamp drivers in a module table.
return {...}
