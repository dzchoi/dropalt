extern "C" {
#include "lua_run.h"            // include "lua.h", which declares lua_*().
#include "lauxlib.h"            // declares luaL_*().
#include "lualib.h"             // luaopen_*()
}

#include "assert.h"
#include "log.h"

#include "lua.hpp"



namespace lua {

static constexpr size_t LUA_MEM_SIZE = 100 *1024;

static uint8_t lua_memory[LUA_MEM_SIZE] __attribute__((section(".noinit")));

// Lua keymap script and Lua Repl will share the same lua State.
static lua_State* L;



// Print all values of any type on the stack like Lua `print` (LuaB_print()) does.
// However, it prints each value on a separate line instead of joining them with '\t'.
static void print_all(lua_State* L)
{
    for ( int i = -lua_gettop(L) ; i < 0 ; i++ ) {
        size_t l;
        const char* s = luaL_tolstring(L, i, &l);
        lua_writestring(s, l);
        lua_writeline();
        lua_pop(L, 1);
    }
    lua_settop(L, 0);  // Remove all values from the stack.

    // Alternatively, we could use "print" (i.e. luaB_print) from Lua base library.
    // int n = lua_gettop(L);
    // if ( n > 0 ) {  // Any result to print?
    //     // luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
    //     lua_getglobal(L, "print");
    //     lua_insert(L, 1);
    //     status = lua_pcall(L, n, 0, 0);
    // }
}

// Print (calling the Lua 'print' function) any values on the stack.
// Check whether 'status' is not OK and, if so, prints the error message on the top of
// the stack. It assumes that the error object is a string, as it was either
// generated by Lua or by 'msghandler'.
static void report(status_t status)
{
    if ( status == LUA_OK || status == LUA_ERRRUN )
        // We do not add "remote:" to the error message as it already has the chunkname.
        print_all(L);
    else {
        l_message(lua_tostring(L, -1));
        lua_pop(L, 1);  // remove the error message.
    }

    assert( lua_gettop(L) == 0 );
}

// Lua panic function invoked when an error occurs outside a protected environment.
static int _panic(lua_State* L)
{
    l_message(lua_tostring(L, -1));
    return 0;
}



void init()
{
    L = lua_riot_newstate(lua_memory, sizeof(lua_memory), _panic);
    assert( L != nullptr );

    lua_pushstring(L, LUA_COPYRIGHT);
    print_all(L);

    // Load some of the standard libraries.
    // Note: Calling lua_riot_openlibs() would enlarge the binary by linking all the
    // modules even if we do not use some of them.
    luaL_requiref(L, "_G", luaopen_base, 1);  // Load into the global environment.
    // luaL_requiref(L, LUA_COLIBNAME, luaopen_coroutine, 1);   // 2K
    // luaL_requiref(L, LUA_TABLIBNAME, luaopen_table, 1);      // 3.3K
    // luaL_requiref(L, LUA_IOLIBNAME, luaopen_io, 1);          // 10.9K
    // luaL_requiref(L, LUA_OSLIBNAME, luaopen_os, 1);          // 18K
    // luaL_requiref(L, LUA_STRLIBNAME, luaopen_string, 1);     // 8.3K
    // luaL_requiref(L, LUA_UTF8LIBNAME, luaopen_utf8, 1);      // 1.4K
    // luaL_requiref(L, LUA_MATHLIBNAME, luaopen_math, 1);      // 10.4K
    // luaL_requiref(L, LUA_DBLIBNAME, luaopen_debug, 1);       // 4.8K
    // Call luaopen_package() in contrib/lua_loadlib.c.
    luaL_requiref(L, LUA_LOADLIBNAME, luaopen_package, 1);      // 0.6K
    // luaL_requiref(L, LUA_BITLIBNAME, luaopen_bit32, 1);  // Error!
    lua_settop(L, 0);  // Remove the libs on the stack.

    // Todo: Would better put this code in the bytecode.
    lua_getglobal(L, "collectgarbage");
    lua_pushstring(L, "count");
    status_t status = lua_pcall(L, 1, 1, 0);  // One argument and one result.
    report(status);
}

}
