## NKRO
Supports both 6KRO and NKRO, configurable through firmware.

## Typing ahead
Users can type even while the USB connection is inactive; typed keys will be delivered automatically once the connection is restored.

However:
- A maximum of **16 keys** can be queued.
- Queued keys expire after **4 seconds**, and are discarded to prevent stale input.

## USB hub
The built-in USB hub supports two USB ports. One port can be connected to the keyboard, while the other port can be used for additional devices such as a mouse or smartphone. 

You can even connect two PCs to these ports and seamlessly switch between them. Additionally, it supports automatic "switchover", which automatically switches to the other PC when the current one disconnects.

## Monolithic firmware
The firmware is a **monolithic image** that integrates both the bootloader and application; no separate bootloader is used.

The system operates in one of two modes:

### Normal Mode
This is the standard operating mode where the device functions as a fully operational keyboard.

### DFU Mode
DFU (Device Firmware Upgrade) mode is used for flashing new firmware or recovering from critical errors.

The system enters DFU mode under the following conditions:
- When flashing new firmware using `dfu-util`
- When the external **Reset** pin is pressed
- When `fw.dfu_mode()` is executed from the Lua REPL or triggered via a keymap

> **Failsafe:** If a critical error occurs (e.g. a runtime error while executing Lua bytecode), the system automatically enters DFU mode to prevent further issues.

To manually exit DFU mode and return to normal mode, press **ESC** (or **\`**).

## DFU Protocol
Support the DFU protocol to flash the firmware and the Lua Keymap module, and fully compatible with [`dfu-util`](https://dfu-util.sourceforge.net/). See `how_to_build.md` for dfu-util commands in detail.

## Logging in backup RAM
You can monitor logs in real-time using a serial terminal on the host PC. Additionally, these logs are stored in the backup RAM (8KB) using a circular buffer mechanism. This ensures that even if the keyboard encounters an error, the logs are preserved. You can retrieve these stored logs using `dfu-util` while in DFU mode, providing valuable diagnostic information for troubleshooting and debugging.

## CDC ACM
The CDC ACM (Communications Device Class - Abstract Control Model) feature allows the keyboard to appear as a virtual serial port to the host computer, facilitating communication over USB with legacy serial terminals.

The CDC ACM allows you to monitor real-time logs generated by the keyboard. For instance, you can use commands like `cat /dev/ttyACMx` or `tio -mINLCRNL /dev/ttyACMx` on Linux to view the logs. Set the ENABLE_CDC_ACM flag to true in config.hpp to enable the CDC ACM feature.

## Embedded Lua
The firmware embeds a Lua virtual machine to execute scripts at power-up and in response to key events (presses and releases), enabling highly customizable keyboard behavior.

The keymap module is composed of multiple scripts:
  - A core script that implements the key event driver (engine)
  - One or more user-defined scripts for custom key mappings

Together, these scripts define how key events are interpreted and handled.

At runtime, the firmware invokes the keymap module through a single entry point—the keymap driver—which is automatically triggered on each key press or release. This enables real-time execution of user-defined logic.

All scripts are compiled together using the `daluac` tool and merged into a single Lua bytecode file for performance and compactness. This bytecode is deployed to **slot 0** using `dfu-util`.

For guidance on writing keymap scripts, compiling with daluac, and flashing via `dfu-util`, refer to `lua_embedded/keymap.lua`.

Note: This feature is integrated independently of CDC ACM.

## Keymap Definition Language
Provides a domain-specific language in Lua for defining custom keymaps, including:
- `Lit()`
- `ModIf()`
- `TapHold()`
- `TapSeq()`
- ...

## Lua REPL (Read-Eval-Print-Loop)
The Lua interpreter is also accessible via the Lua REPL using the dedicated serial terminal, `dalua`, which enables immediate execution of typed Lua code.
```
$ dalua
Connected to /dev/serial/by-id/usb-Massdrop_Drop_ALT_15HMMKAG010321-if00
Lua 5.3.6  Copyright (C) 1994-2020 Lua.org, PUC-Rio
> print "Hello, World."
Hello, World.
> fw = require "fw"
> fw.led0(1)
> 
```

As can be seen, the "fw" module is accessible through the REPL, which allows direct interaction with certain firmware functions. This functionality can be utilized to configure various settings on the keyboard.

Note: This feature depends on CDC ACM.

## Using TLSF for dynamic memory allocation.

The TLSF (Two-Level Segregated Fit) memory allocator is designed for real-time systems and embedded environments where predictable and efficient memory management is critical.

See http://www.gii.upv.es/tlsf/files/papers/ecrts04_tlsf.pdf.

## NVM

The non-volatile memory (NVM) subsystem provides persistent storage backed by SEEPROM on SAMD51, enabling data retention across power cycles. It supports dynamic allocation and seamless access to NVM variables from both firmware and Lua scripts. This flexibility enables users to adjust keyboard settings interactively via the Lua keymap module (e.g. `fw.nvm.last_host_port = 2`).

The SEEPROM is structured as a single associative array, providing efficient storage and retrieval of name-value pairs. Internally, the SEEPROM space (4K) is organized as a sequential structure where name-value pairs are stored contiguously, with all fields laid out back-to-back without any alignment or padding to optimize space usage.
