#### USB hub
The built-in USB hub supports two USB ports. One port can be connected to the keyboard, while the other port can be used for additional devices such as a mouse or smartphone. 

You can even connect two PCs to these ports and seamlessly switch between them. Additionally, it supports automatic "switchover", which automatically switches to the other PC when the current one disconnects.

#### Bootloader
The new bootloader, built on ["riotboot"](https://api.riot-os.org/group__bootloader__riotboot.html), serves as a replacement for the original [mdloader](https://github.com/Massdrop/mdloader) bootloader. It supports the DFU protocol and is fully compatible with [`dfu-util`](https://dfu-util.sourceforge.net/). The flash memory is organized into two distinct slots:
- Slot 0: Firmware
- Slot 1: Lua bytecode (the keymap module)

To enter the bootloader (so called DFU mode), you can press the external Reset pin. Or if the firmware encounters a critical error (e.g a runtime error when executing Lua bytecode), the bootloader will automatically be entered.

You can:
- Flash firmware:
  > $ dfu-util --alt 0 --download `firmware.bin`
- Flash Lua bytecode:
  > $ dfu-util --alt 1 --download `keymap.bin`
- Retrieve logs:
  > $ dfu-util --alt 0 --upload `logs.txt`

#### Logging in backup RAM
You can monitor logs in real-time using a serial terminal on the host PC. Additionally, these logs are stored in the backup RAM (8KB) using a circular buffer mechanism. This ensures that even if the keyboard encounters an error, the logs are preserved. You can retrieve these stored logs using `dfu-util` while in DFU mode, providing valuable diagnostic information for troubleshooting and debugging.

#### CDC ACM
The CDC ACM (Communications Device Class - Abstract Control Model) feature allows the keyboard to appear as a virtual serial port to the host computer, facilitating communication over USB with legacy serial terminals.

The CDC ACM allows you to monitor real-time logs generated by the keyboard. For instance, you can use commands like `cat /dev/ttyACMx` or `tio -mINLCRNL /dev/ttyACMx` on Linux to view the logs. Set the ENABLE_CDC_ACM flag to true in config.hpp to enable the CDC ACM feature.

#### Embedded Lua
A Lua interpreter (Lua virtual machine) is integrated into the firmware to execute Lua script during power-up and in response to key events (presses/releases). This powerful capability allows you to create custom key mappings using a Lua script, called the keymap module.

The keymap module interacts with the firmware to catch key events, execute Lua functions, and perform various additional tasks to enhance the keyboard's capabilities.

The Lua script is dowloaded to slot **1** separately from the firmware. For the purposes of efficiency and performance, the script is downloaded as compiled bytecode rather than plain text. For detailed instructions on writing a keymap module, compiling and downloading, refer to lua_emb/keymap.lua.

This feature does not require CDC ACM.

#### Lua REPL (Read-Eval-Print-Loop)
This feature requires CDC ACM.

TBD: Use `luada` to run Lua Repl on the keyboard.

#### Using TLSF for dynamic memory allocation.

The TLSF (Two-Level Segregated Fit) memory allocator is designed for real-time systems and embedded environments where predictable and efficient memory management is critical. Here are its key features:

* Constant-Time Allocation and Deallocation:  
TLSF provides O(1) time complexity for both allocation and deallocation operations, ensuring consistent and predictable performance, which is essential for real-time systems.

* Low Fragmentation:  
TLSF effectively minimizes memory fragmentation by segregating memory into different size classes, making it highly efficient in managing memory blocks of various sizes.

* Real-Time Suitability:  
With its constant-time operations and low fragmentation, TLSF is well-suited for real-time and embedded systems where deterministic behavior is crucial.

* Efficient Memory Utilization:  
TLSF uses a two-level segregated fit strategy, which combines the benefits of fast-fit allocation (for small blocks) and segregated free lists (for larger blocks). This ensures efficient memory utilization and reduces waste.

* Low Overhead:  
The allocator has minimal overhead, making it ideal for resource-constrained environments where every byte of memory counts.

* Thread Safety:  
Although TLSF itself is not inherently thread-safe, it can be combined with synchronization mechanisms (e.g., mutexes) to ensure safe memory allocation in multi-threaded environments.

See http://www.gii.upv.es/tlsf/files/papers/ecrts04_tlsf.pdf.
