#### Keyboard Capabilities

Supports both 6KRO and NKRO, configurable through firmware.

#### Typing ahead
Users can type even while the USB connection is inactive; typed keys will be delivered automatically once the connection is restored.

However:
- A maximum of **16 keys** can be queued.
- Queued keys expire after **4 seconds**, and are discarded to prevent stale input.

#### USB hub
The built-in USB hub supports two USB ports. One port can be connected to the keyboard, while the other port can be used for additional devices such as a mouse or smartphone. 

You can even connect two PCs to these ports and seamlessly switch between them. Additionally, it supports automatic "switchover", which automatically switches to the other PC when the current one disconnects.

#### Bootloader
The new bootloader, built on ["riotboot"](https://api.riot-os.org/group__bootloader__riotboot.html), serves as a replacement for the original [mdloader](https://github.com/Massdrop/mdloader) bootloader. It supports the DFU protocol and is fully compatible with [`dfu-util`](https://dfu-util.sourceforge.net/). The flash memory is organized into two distinct slots:
- Slot 0: Firmware
- Slot 1: Lua bytecode (the keymap module)

To enter the bootloader (so called DFU mode), you can press the external Reset pin. Or if the firmware encounters a critical error (e.g a runtime error when executing Lua bytecode), the bootloader will automatically be entered.

You can:
- Flash firmware:
  > $ dfu-util --alt 0 --download `firmware.bin`
- Flash Lua bytecode:
  > $ dfu-util --alt 1 --download `keymap.bin`
- Retrieve logs:
  > $ dfu-util --alt 0 --upload `logs.txt`

#### Logging in backup RAM
You can monitor logs in real-time using a serial terminal on the host PC. Additionally, these logs are stored in the backup RAM (8KB) using a circular buffer mechanism. This ensures that even if the keyboard encounters an error, the logs are preserved. You can retrieve these stored logs using `dfu-util` while in DFU mode, providing valuable diagnostic information for troubleshooting and debugging.

#### CDC ACM
The CDC ACM (Communications Device Class - Abstract Control Model) feature allows the keyboard to appear as a virtual serial port to the host computer, facilitating communication over USB with legacy serial terminals.

The CDC ACM allows you to monitor real-time logs generated by the keyboard. For instance, you can use commands like `cat /dev/ttyACMx` or `tio -mINLCRNL /dev/ttyACMx` on Linux to view the logs. Set the ENABLE_CDC_ACM flag to true in config.hpp to enable the CDC ACM feature.

#### Embedded Lua
The firmware embeds a Lua virtual machine to execute scripts at power-up and in response to key events (presses and releases), enabling highly customizable keyboard behavior.

The keymap module is composed of multiple scripts:
  - A core script that implements the key event driver (engine)
  - One or more user-defined scripts for custom key mappings

Together, these scripts define how key events are interpreted and handled.

At runtime, the firmware invokes the keymap module through a single entry point—the keymap driver—which is automatically triggered on each key press or release. This enables real-time execution of user-defined logic.

All scripts are compiled together using the `daluac` tool and merged into a single Lua bytecode file for performance and compactness. This bytecode is deployed to **slot 1** using `dfu-util`.

For guidance on writing keymap scripts, compiling with daluac, and flashing via dfu-util, refer to `lua_emb/keymap.lua`.

Note: This feature is integrated independently of CDC ACM.

#### Keymap Definition Language
Provides a domain-specific language in Lua for defining custom keymaps, including:
- Lit()
- ModIf()
- TapHold()
- TapSeq()
- ...

#### Lua REPL (Read-Eval-Print-Loop)
The Lua interpreter is also accessible via the Lua REPL using the dedicated serial terminal, `dalua`, which enables immediate execution of typed Lua code.
```
$ dalua
Connected to /dev/serial/by-id/usb-Massdrop_Drop_ALT_15HMMKAG010321-if00
Lua 5.3.6  Copyright (C) 1994-2020 Lua.org, PUC-Rio
> print "Hello, World."
Hello, World.
> fw = require "fw"
> fw.led0(1)
> 
```

As can be seen, the "fw" module is accessible through the REPL, which allows direct interaction with certain firmware functions. This functionality can be utilized to configure various settings on the keyboard.

Note: This feature depends on CDC ACM.

#### Using TLSF for dynamic memory allocation.

The TLSF (Two-Level Segregated Fit) memory allocator is designed for real-time systems and embedded environments where predictable and efficient memory management is critical. Here are its key features:

* Constant-Time Allocation and Deallocation:  
TLSF provides O(1) time complexity for both allocation and deallocation operations, ensuring consistent and predictable performance, which is essential for real-time systems.

* Low Fragmentation:  
TLSF effectively minimizes memory fragmentation by segregating memory into different size classes, making it highly efficient in managing memory blocks of various sizes.

* Real-Time Suitability:  
With its constant-time operations and low fragmentation, TLSF is well-suited for real-time and embedded systems where deterministic behavior is crucial.

* Efficient Memory Utilization:  
TLSF uses a two-level segregated fit strategy, which combines the benefits of fast-fit allocation (for small blocks) and segregated free lists (for larger blocks). This ensures efficient memory utilization and reduces waste.

* Low Overhead:  
The allocator has minimal overhead, making it ideal for resource-constrained environments where every byte of memory counts.

* Thread Safety:  
Although TLSF itself is not inherently thread-safe, it can be combined with synchronization mechanisms (e.g., mutexes) to ensure safe memory allocation in multi-threaded environments.

See http://www.gii.upv.es/tlsf/files/papers/ecrts04_tlsf.pdf.

#### NVM

The non-volatile memory (NVM) subsystem provides persistent storage backed by SEEPROM on SAMD51, enabling data retention across power cycles. It supports dynamic allocation and seamless access to NVM variables from both firmware and Lua scripts. This flexibility enables users to adjust keyboard settings interactively via the Lua keymap module (e.g. fw.nvm.enable_nkro = true).

The SEEPROM is structured as a single associative array, providing efficient storage and retrieval of name-value pairs. Internally, the SEEPROM space (4K) is organized as a sequential structure where name-value pairs are stored contiguously, with all fields laid out back-to-back without any alignment or padding to optimize space usage.
