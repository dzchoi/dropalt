#### USB hub
The built-in USB hub supports two USB ports. One port can be connected to the keyboard, while the other port can be used for additional devices such as a mouse or smartphone. 

You can even connect two PCs to these ports and seamlessly switch between them. Additionally, it supports automatic "switchover", which automatically switches to the other PC when the current one disconnects.

#### Bootloader
The customized RIOT bootloader replaces the original `mdloader` bootloader and is fully compatible with `dfu-util`. It offers two slots for downloading. Using `dfu-util`, you can download the firmware to slot 0 and the Lua bytecode to slot 1.

To enter the bootloader (DFU mode), you can press the external Reset pin. Additionally, if the firmware encounters a critical error, the bootloader will automatically be entered, allowing you to access the logs.

#### Logging in backup RAM
You can monitor logs in real-time using a serial terminal on the host PC. Additionally, these logs are stored in the backup RAM (8KB) using a circular buffer mechanism. This ensures that even if the keyboard encounters an error, the logs are preserved. You can retrieve these stored logs using `dfu-util` while in DFU mode, providing valuable diagnostic information for troubleshooting and debugging.

#### CDC ACM
The CDC ACM (Communications Device Class - Abstract Control Model) feature allows the keyboard to appear as a virtual serial port to the host computer, facilitating communication over USB with legacy serial terminals.

The CDC ACM allows you to monitor real-time logs generated by the keyboard. For instance, you can use commands like `cat /dev/ttyACMx` or `tio -mINLCRNL /dev/ttyACMx` on Linux to view the logs. Set the ENABLE_CDC_ACM flag to true in config.hpp to enable the CDC ACM feature.

#### Embedded Lua
An embedded Lua interpreter (Lua virtual machine) is integrated to execute a Lua script during power-up and when key events (press/release) occur. This powerful feature allows you to customize key mappings and behavior to suit your specific needs.

The Lua interpreter interacts with the firmware to manage key events, execute Lua functions, and perform other tasks. By embedding Lua, you can create highly flexible and personalized keyboard functionality.

The Lua script can be dowloaded to slot **1** independently of the firmware. Rather than downloading the script as plain text, it is compiled into Lua bytecode and then flashed to the keyboard. This approach not only optimizes the Lua interpreter but also enhances the performance of script execution, ensuring efficient and effective operation.

This feature does not require CDC ACM.

TBD: Use `luacda` to compile.

#### Lua REPL (Read-Eval-Print-Loop)
This feature requires CDC ACM.

TBD: Use `luada` to run Lua Repl on the keyboard.

#### Using TLSF for dynamic memory allocation.

The TLSF (Two-Level Segregated Fit) memory allocator is designed for real-time systems and embedded environments where predictable and efficient memory management is critical. Here are its key features:

* Constant-Time Allocation and Deallocation:  
TLSF provides O(1) time complexity for both allocation and deallocation operations, ensuring consistent and predictable performance, which is essential for real-time systems.

* Low Fragmentation:  
TLSF effectively minimizes memory fragmentation by segregating memory into different size classes, making it highly efficient in managing memory blocks of various sizes.

* Real-Time Suitability:  
With its constant-time operations and low fragmentation, TLSF is well-suited for real-time and embedded systems where deterministic behavior is crucial.

* Efficient Memory Utilization:  
TLSF uses a two-level segregated fit strategy, which combines the benefits of fast-fit allocation (for small blocks) and segregated free lists (for larger blocks). This ensures efficient memory utilization and reduces waste.

* Low Overhead:  
The allocator has minimal overhead, making it ideal for resource-constrained environments where every byte of memory counts.

* Thread Safety:  
Although TLSF itself is not inherently thread-safe, it can be combined with synchronization mechanisms (e.g., mutexes) to ensure safe memory allocation in multi-threaded environments.

See http://www.gii.upv.es/tlsf/files/papers/ecrts04_tlsf.pdf.
